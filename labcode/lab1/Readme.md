<h1 align="center"> 南开大学操作系统实验一 </h1>
<p align="center">
<a href="https://cc.nankai.edu.cn/"><img src="https://img.shields.io/badge/NKU-CS-07679f"></a>
<a href="http://oslab.mobisys.cc/"><img src="https://img.shields.io/badge/NKU-OS-86006a"></a>
</p>
<h5 align="center"><em>章壹程，仇科文，杨宇翔 </em></h5>
<p align="center">
<p align="center">
  <a href="#练习一">练习一</a>|
  <a href="#练习二">练习二</a>|
  <a href="#分工">分工</a>
</p>

# 练习一：理解内核启动中的程序入口操作

# 练习二: 使用GDB验证启动流程
#### RISC-V 硬件加电后最初执行的几条指令位于什么地址？

> 位于0x1000

程序启动时 CPU 会从复位地址（`0x1000`）开始执行初始化固件（OpenSBI）的汇编代码，进行最基础的硬件初始化。



#### 它们主要完成了哪些功能？

GDB 成功连上 QEMU 后，此时程序正准备开始执行初始化固件（OpenSBI）的汇编代码。使用 `x/ni $pc` 可以显示从当前程序计数器（`$pc`寄存器）开始的 `n` 条指令，利用这个指令即可看到RISC-V 硬件加电后最初执行的几条指令，指令及其解释如下。

```assembly
0x1000: auipc	t0,0x0 	
#将当前PC值的高20位与立即数0相加，结果存入t0寄存器，得到全局地址0x1000。
0x1004:	addi	a1,t0,32
#将t0中的值加上十进制32，结果存入a1寄存器。此时a1中的值为0x1020，这个地址可能指向某些数据或配置。
0x1008:	csrr	a0,mhartid 
#将当前硬件线程（hart）的唯一标识符从专用的控制和状态寄存器（CSR）mhartid读取到a0寄存器中，这样可以在多核系统中区分不同的核心。
0x100c:	ld	t0,24(t0)
#从内存地址 [t0 + 24]处加载一个64位的值到t0寄存器。监控到后续跳转到地址 0x80000000，地址0x1018处存放的值应该就是0x80000000。
0x1010:	jr	t0 
#跳转到t0寄存器中所包含的地址。
```

后续可以使用`si`逐条执行机器指令以精确跟踪，或者利用在特定地址设置断点来跳转。



跳转到 0x80000000 后，控制权就交给了 **OpenSBI** 。 它是RISC-V系统中运行在机器模式（M-mode）下的固件，相当于传统PC中的BIOS，主要任务是**为后续操作系统内核的运行准备一个稳定的硬件环境**。后续的指令非常繁琐冗长，难以跟踪，以下面的指令片段为例：

```assembly
0x80000554:  li      sp,0                                         
0x80000556:  li      gp,0                                         
0x80000558:  li      tp,0                                        
0x8000055a:  li      t0,0                                     
0x8000055c:  li      t1,0                                    
0x8000055e:  li      t2,0  
0x80000560:  li      s0,0 
0x80000562:  li      s1,0      
0x80000564:  li      a3,0         
0x80000566:  li      a4,0  
0x80000568:  li      a5,0 
0x8000056a:  li      a6,0        
0x8000056c:  li      a7,0       
0x8000056e:  li      s2,0   
0x80000570:  li      s3,0  
0x80000572:  li      s4,0                                     
0x80000574:  li      s5,0                                     
0x80000576:  li      s6,0   
0x80000578:  li      s7,0                                         
0x8000057a:  li      s8,0
```

可以看到这段指令片段是在**系统性地清零大多数通用寄存器**。这主要是为了给后续的 C 语言主初始化函数（如 `sbi_init()`）提供一个干净、确定的运行环境。



# 分工

- [章壹程](https://github.com/u2003yuge)：环境配置、Readme.md排版、git管理
- [仇科文](https://github.com/luyanhexay)：完成问题一
- [杨宇翔](https://github.com/sheepspacefly)：完成问题二