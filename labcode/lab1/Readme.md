<h1 align="center"> 南开大学操作系统实验一 </h1>
<p align="center">
<a href="https://cc.nankai.edu.cn/"><img src="https://img.shields.io/badge/NKU-CS-07679f"></a>
<a href="http://oslab.mobisys.cc/"><img src="https://img.shields.io/badge/NKU-OS-86006a"></a>
</p>
<h5 align="center"><em>章壹程，仇科文，杨宇翔 </em></h5>
<p align="center">
<p align="center">
  <a href="#练习一">练习一</a>|
  <a href="#练习二">练习二</a>|
  <a href="#分工">分工</a>
</p>

## 练习一：理解内核启动中的程序入口操作

> 题目要求：阅读 kern/init/entry.S 内容代码，结合操作系统内核启动流程，说明指令 la sp, bootstacktop 完成了什么操作，目的是什么？ tail kern_init 完成了什么操作，目的是什么？

### 1. la sp, bootstacktop 所完成的操作

`la sp, bootstacktop` 是一条 RISC-V 汇编指令，其中各个部分的含义如下：

- `la` 是 “load address” 的缩写，用于将第二个操作数的地址加载到第一个操作数中。
- `sp` 是栈指针寄存器，它指向栈顶。
- `bootstacktop` 是预定义的栈顶地址符号。

因此，这条指令所完成的操作是：将 `bootstacktop` 的地址加载到栈指针寄存器 `sp` 中，即设置栈指针指向内核启动栈的顶部。

### 2. la sp, bootstacktop 的目的

设置栈指针的目的是为内核提供可用的栈空间。将栈指针设置为 `bootstacktop`之后，内核就可以使用预分配的栈空间**进行后续的初始化操作**。

### 3. tail kern_init 所完成的操作

`tail kern_init`中各个部分的含义如下：

- `tail` 是尾调用指令，类似于跳转（`call`），但会优化调用栈。
- `kern_init` 是内核初始化函数的地址，这个函数的定义见[init.c](kern/init/init.c)。

因此，这条指令将程序控制流转移到 `kern_init` 函数，从而开始执行内核的 C 语言初始化代码（虽然目前这个代码只有打印信息和死循环两个功能）。

### 4. tail kern_init 的目的

使用 `tail` 指令跳转到 `kern_init` 的目的是从汇编代码切换到 C 语言代码执行，从而开始内核的主要初始化流程。使用 `tail` 指令而不是 `call` 的目的是利用 `tail` 指令的优化特性，避免不必要的栈帧创建。

### 5. 与此对应的 OS 原理知识点

`la sp, bootstacktop`对应 OS 原理中的栈初始化，保证内核在执行高级代码逻辑时有可用的栈空间进行函数调用和局部变量管理。`tail kern_init`对应 OS 原理中的控制权转移，使执行流从汇编语言的底层环境配置转移到 C 语言的高级内核初始化函数。

这两条指令共同完成了内核自身初始化阶段的启动操作。在 RISC-V 平台上，它们是在固件（即本实验中的 OpenSBI）完成了第一阶段的系统引导，并将控制权转移到内核的入口点（0x80200000）之后才开始执行的。

## 练习二: 使用 GDB 验证启动流程

### RISC-V 硬件加电后最初执行的几条指令位于什么地址？

> 位于 0x1000

程序启动时 CPU 会从复位地址（`0x1000`）开始执行初始化固件（OpenSBI）的汇编代码，进行最基础的硬件初始化。

### 它们主要完成了哪些功能？

GDB 成功连上 QEMU 后，此时程序正准备开始执行初始化固件（OpenSBI）的汇编代码。使用 `x/ni $pc` 可以显示从当前程序计数器（`$pc`寄存器）开始的 `n` 条指令，利用这个指令即可看到 RISC-V 硬件加电后最初执行的几条指令，指令及其解释如下。

```assembly
0x1000: auipc	t0,0x0
#将当前PC值的高20位与立即数0相加，结果存入t0寄存器，得到全局地址0x1000。
0x1004:	addi	a1,t0,32
#将t0中的值加上十进制32，结果存入a1寄存器。此时a1中的值为0x1020，这个地址可能指向某些数据或配置。
0x1008:	csrr	a0,mhartid
#将当前硬件线程（hart）的唯一标识符从专用的控制和状态寄存器（CSR）mhartid读取到a0寄存器中，这样可以在多核系统中区分不同的核心。
0x100c:	ld	t0,24(t0)
#从内存地址 [t0 + 24]处加载一个64位的值到t0寄存器。监控到后续跳转到地址 0x80000000，地址0x1018处存放的值应该就是0x80000000。
0x1010:	jr	t0
#跳转到t0寄存器中所包含的地址。
```

后续可以使用`si`逐条执行机器指令以精确跟踪，或者利用在特定地址设置断点来跳转。

跳转到 0x80000000 后，控制权就交给了 **OpenSBI** 。 它是 RISC-V 系统中运行在机器模式（M-mode）下的固件，相当于传统 PC 中的 BIOS，主要任务是**为后续操作系统内核的运行准备一个稳定的硬件环境**。后续的指令非常繁琐冗长，难以跟踪，以下面的指令片段为例：

```assembly
0x80000554:  li      sp,0
0x80000556:  li      gp,0
0x80000558:  li      tp,0
0x8000055a:  li      t0,0
0x8000055c:  li      t1,0
0x8000055e:  li      t2,0
0x80000560:  li      s0,0
0x80000562:  li      s1,0
0x80000564:  li      a3,0
0x80000566:  li      a4,0
0x80000568:  li      a5,0
0x8000056a:  li      a6,0
0x8000056c:  li      a7,0
0x8000056e:  li      s2,0
0x80000570:  li      s3,0
0x80000572:  li      s4,0
0x80000574:  li      s5,0
0x80000576:  li      s6,0
0x80000578:  li      s7,0
0x8000057a:  li      s8,0
```

可以看到这段指令片段是在**系统性地清零大多数通用寄存器**。这主要是为了给后续的 C 语言主初始化函数（如 `sbi_init()`）提供一个干净、确定的运行环境。

## 分工

- [章壹程](https://github.com/u2003yuge)：环境配置、Readme.md 排版、git 管理
- [仇科文](https://github.com/luyanhexay)：完成问题一
- [杨宇翔](https://github.com/sheepspacefly)：完成问题二
